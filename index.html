<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Serial Sensor Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .chart-wrapper {
      position: relative;
      margin-bottom: 40px;
    }
    .chart-container {
      width: 100%;
      height: 100%;
    }
    #log {
      white-space: pre-wrap;
      background: #f0f0f0;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    button {
      padding: 10px 15px;
      font-size: 1em;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <button id="connect">ðŸ”Œ Connect</button>
  <button id="clearLog">ðŸ§¹ Clear Log</button>
  <div id="charts"></div>
  <pre id="log"></pre>

  <script>
    let port, charts = {}, config;
    const log = document.getElementById('log');
    let timeStart = performance.now();
    const MAX_POINTS = 1000;

    async function loadConfig() {
      const res = await fetch("https://raw.githubusercontent.com/WeSpeakEnglish/polluSensWeb/refs/heads/main/SN-GCJA5.json");
      config = await res.json();
    }

    function initializeCharts() {
      const chartsContainer = document.getElementById('charts');
      chartsContainer.innerHTML = '';
      charts = {};
      for (const [chartGroup, group] of Object.entries(config.charts)) {
        const wrapper = document.createElement('div');
        wrapper.className = 'chart-wrapper';

        const canvas = document.createElement('canvas');
        canvas.className = 'chart-container';

        const [width, height] = group.size || [600, 300];
        wrapper.style.maxWidth = `${width}px`;
        wrapper.style.height = `${height}px`;
        wrapper.style.width = '100%';

        wrapper.appendChild(canvas);
        chartsContainer.appendChild(wrapper);

        charts[chartGroup] = new Chart(canvas, {
          type: 'line',
          data: {
            datasets: group.datasets.map(([label, field, color, tension]) => ({
              label,
              data: [],
              borderColor: color,
              tension: tension ?? 0.3,
              borderWidth: 1,
              fill: false,
              pointRadius: 0
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Time (s)' }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: chartGroup }
              }
            },
            plugins: {
              legend: { position: 'top' }
            }
          }
        });
      }
    }

    function updateCharts(parsedData) {
      const now = (performance.now() - timeStart) / 1000;
      for (const [chartGroup, chart] of Object.entries(charts)) {
        const datasets = config.charts[chartGroup].datasets;
        datasets.forEach(([label, field], i) => {
          const value = parsedData[field];
          if (value !== undefined) {
            chart.data.datasets[i].data.push({ x: now, y: value });
            if (chart.data.datasets[i].data.length > MAX_POINTS) {
              chart.data.datasets[i].data.shift();
            }
          }
        });
        chart.update('none');
      }
    }

    async function readLoop(reader) {
      const { frame, checksum, data: dataFields } = config;
      let buffer = [];

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer.push(...value);

        while (buffer.length >= frame.length) {
          const slice = buffer.slice(0, frame.length);
          if (slice[0] === frame.startByte && slice[frame.length - 1] === frame.endByte) {
            const data = slice;
            const valid = eval(checksum.eval) === eval(checksum.compare);
            if (valid) {
              const parsed = {};
              for (const [name, expr] of Object.entries(dataFields)) {
                parsed[name] = eval(expr);
              }
              updateCharts(parsed);

              // Format packet as hex (no 0x)
              const hexPacket = data.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
              let output = `ðŸ“¦ [${hexPacket}]\nChecksum: âœ…`;

              // Avoid duplicate field values in log
              const seenFields = new Set();
              for (const groupConf of Object.values(config.charts)) {
                for (const [label, field] of groupConf.datasets) {
                  if (!seenFields.has(field) && parsed[field] !== undefined) {
                    output += `\n${label}: ${parsed[field]}`;
                    seenFields.add(field);
                  }
                }
              }

              log.textContent += output + '\n';
            } else {
              log.textContent += `âŒ Bad checksum\n`;
            }
            buffer = buffer.slice(frame.length);
          } else {
            buffer.shift();
          }
        }
      }
    }

    document.getElementById('connect').addEventListener('click', async () => {
      await loadConfig();
      initializeCharts();
      try {
        port = await navigator.serial.requestPort();
        await port.open(config.port);
        const reader = port.readable.getReader();
        log.textContent += 'âœ… Port opened\n';
        await readLoop(reader);
      } catch (err) {
        log.textContent += `âŒ ${err.message}\n`;
      }
    });

    document.getElementById('clearLog').addEventListener('click', () => {
      log.textContent = '';
    });
  </script>
</body>
</html>

