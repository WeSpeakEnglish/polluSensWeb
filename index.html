<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PolluSens Web Serial</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    button { margin-right: 10px; }
    pre { background: #eee; padding: 10px; max-height: 200px; overflow-y: auto; }
    .chart-container { display: block; margin-bottom: 20px; }
  </style>
</head>
<body>
  <h1>PolluSens Web Serial Interface</h1>
  <button id="request-port">Request Port</button>
  <button id="connect" disabled>Connect</button>
  <button id="disconnect" disabled>Disconnect</button>

  <h3>Live Sensor Data</h3>
  <div id="charts"></div>

  <h3>Raw Frames</h3>
  <pre id="log"></pre>

  <script>
    let port, reader, config;
    let isReading = false;
    let buffer = [];
    const chartData = {};
    const charts = {};
    const log = document.getElementById("log");

    async function loadConfig() {
      const response = await fetch("https://raw.githubusercontent.com/WeSpeakEnglish/polluSensWeb/refs/heads/main/SN-GCJA5.json");
      config = await response.json();
      initializeCharts();
    }

    function initializeCharts() {
      const chartsContainer = document.getElementById('charts');
      chartsContainer.innerHTML = '';

      for (const [chartGroup, chartDef] of Object.entries(config.charts)) {
        const datasets = chartDef.datasets || chartDef; // Fallback to old format
        const canvas = document.createElement('canvas');
        canvas.className = 'chart-container';

        if (chartDef.size && Array.isArray(chartDef.size)) {
          canvas.width = chartDef.size[0];
          canvas.height = chartDef.size[1];
        }

        chartsContainer.appendChild(canvas);

        charts[chartGroup] = new Chart(canvas, {
          type: 'line',
          data: {
            datasets: datasets.map(([label, field, color, tension]) => ({
              label,
              data: [],
              borderColor: color,
              borderWidth: 1,
              fill: false,
              pointRadius: 0,
              tension: tension
            }))
          },
          options: {
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Time (s)' }
              },
              y: {
                title: { display: true, text: chartGroup },
                beginAtZero: true
              }
            },
            plugins: { legend: { position: 'top' } },
            animation: false
          }
        });
      }
    }

    document.getElementById('request-port').addEventListener('click', async () => {
      try {
        port = await navigator.serial.requestPort();
        document.getElementById('connect').disabled = false;
        log.textContent += "‚úÖ Port selected.\n";
      } catch (err) {
        log.textContent += `‚ùå Port request failed: ${err}\n`;
      }
    });

    document.getElementById('connect').addEventListener('click', async () => {
      if (!port) return;
      await loadConfig();
      await port.open(config.port);
      log.textContent += `üîå Port opened at ${config.port.baudRate} baud.\n`;

      reader = port.readable.getReader();
      isReading = true;
      document.getElementById('disconnect').disabled = false;
      document.getElementById('connect').disabled = true;
      buffer = [];
      startTime = Date.now() / 1000;
      readLoop();
    });

    let startTime = 0;
    const MAX_POINTS = 1000;

    async function readLoop() {
      const frameLen = config.frame.length;
      const startByte = config.frame.startByte;
      const endByte = config.frame.endByte;

      try {
        while (isReading) {
          const { value, done } = await reader.read();
          if (done || !value) break;

          for (const byte of value) {
            buffer.push(byte);

            while (buffer.length >= frameLen) {
              if (buffer[0] !== startByte) {
                buffer.shift();
                continue;
              }

              const frame = buffer.slice(0, frameLen);
              if (frame[frameLen - 1] !== endByte) {
                buffer.shift();
                continue;
              }

              const data = new Uint8Array(frame);
              const valid = (eval(config.checksum.eval) == eval(config.checksum.compare));

              if (valid) {
                const values = {};
                for (const [field, expr] of Object.entries(config.data)) {
                  try {
                    values[field] = eval(expr);
                  } catch (e) {
                    values[field] = undefined;
                  }
                }

                updateChartData(values);
                log.textContent += `üì¶ [${Array.from(data).join(', ')}]\n`;
                log.textContent += `Checksum: ${valid}\n`;

                for (const [chartGroup, chartDef] of Object.entries(config.charts)) {
                  const datasets = chartDef.datasets || chartDef;
                  for (const [label, field] of datasets) {
                    log.textContent += `‚úÖ ${label}: ${values[field]}\n`;
                  }
                }
              } else {
                log.textContent += `‚ùå Bad checksum\n`;
              }

              buffer.splice(0, frameLen);
            }

            if (buffer.length > 100) {
              buffer = buffer.slice(-50);
            }
          }
        }
      } catch (err) {
        log.textContent += `‚ùå Read error: ${err}\n`;
      } finally {
        reader.releaseLock();
      }
    }

    function updateChartData(values) {
      const timeNow = Date.now() / 1000 - startTime;

      for (const [chartGroup, chartDef] of Object.entries(config.charts)) {
        const datasets = chartDef.datasets || chartDef;
        const chart = charts[chartGroup];
        if (!chart) continue;

        datasets.forEach(([label, field], index) => {
          const val = values[field];
          if (val !== undefined) {
            chart.data.datasets[index].data.push({ x: timeNow, y: val });
            if (chart.data.datasets[index].data.length > MAX_POINTS) {
              chart.data.datasets[index].data.shift();
            }
          }
        });

        chart.update();
      }
    }

    document.getElementById('disconnect').addEventListener('click', async () => {
      isReading = false;

      if (reader) {
        try {
          await reader.cancel();
          await reader.releaseLock();
        } catch {}

        reader = null;
      }

      if (port) {
        try {
          await port.close();
          log.textContent += "üîí Port closed.\n";
        } catch (err) {
          log.textContent += `‚ùå Port close error: ${err}\n`;
        }
      }

      document.getElementById('connect').disabled = false;
      document.getElementById('disconnect').disabled = true;
    });
  </script>
</body>
</html>
