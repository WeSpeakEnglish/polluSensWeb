<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PolluSens Web Serial</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    button { margin-right: 10px; }
    canvas { max-width: 100%; height: 300px; }
    pre { background: #eee; padding: 10px; max-height: 200px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>PolluSens Web Serial Interface</h1>
  <button id="request-port">Request Port</button>
  <button id="connect" disabled>Connect</button>
  <button id="disconnect" disabled>Disconnect</button>
  <h3>Live PM Data</h3>
  <canvas id="chart"></canvas>
  <h3>Raw Frames</h3>
  <pre id="log"></pre>

  <script>
    let port, reader, config;
    let isReading = false;
    let buffer = [];

    const log = document.getElementById("log");
    const connectBtn = document.getElementById("connect");
    const disconnectBtn = document.getElementById("disconnect");

    // Chart.js setup
    const ctx = document.getElementById('chart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'PM1.0', borderColor: 'blue', data: [], tension: 0.2 },
          { label: 'PM2.5', borderColor: 'green', data: [], tension: 0.2 },
          { label: 'PM10', borderColor: 'red', data: [], tension: 0.2 },
        ]
      },
      options: {
        animation: false,
        scales: {
          x: { display: false },
          y: { beginAtZero: true }
        }
      }
    });

    async function loadConfig() {
      const response = await fetch("https://raw.githubusercontent.com/WeSpeakEnglish/polluSensWeb/refs/heads/main/SN-GCJA5.json");
      config = await response.json();
    }

    document.getElementById('request-port').addEventListener('click', async () => {
      try {
        port = await navigator.serial.requestPort();
        connectBtn.disabled = false;
        log.textContent += "‚úÖ Port selected.\n";
      } catch (err) {
        log.textContent += `‚ùå Port request failed: ${err}\n`;
      }
    });

    connectBtn.addEventListener('click', async () => {
      if (!port) return;

      await loadConfig();
      await port.open(config.port);
      log.textContent += `üîå Port opened at ${config.port.baudRate} baud.\n`;

      reader = port.readable.getReader();
      isReading = true;
      disconnectBtn.disabled = false;
      connectBtn.disabled = true;
      buffer = [];

      readLoop();
    });

    async function readLoop() {
      const frameLen = config.frame.length;
      const startByte = config.frame.startByte;
      const endByte = config.frame.endByte;

      try {
        while (isReading) {
          const { value, done } = await reader.read();
          if (done || !value) break;

          for (const byte of value) {
            buffer.push(byte);

            // Try finding a valid frame in the buffer
            while (buffer.length >= frameLen) {
              if (buffer[0] !== startByte) {
                buffer.shift();
                continue;
              }

              const frame = buffer.slice(0, frameLen);
              if (frame[frameLen - 1] !== endByte) {
                buffer.shift(); // discard and retry from next byte
                continue;
              }

              const data = new Uint8Array(frame);
              const valid = true;//Function("data", config.checksum.eval)(data);

              if (valid) {
                const pm1 = (data[config.data.pm1] << 8) | data[config.data.pm1 + 1];
                const pm25 = (data[config.data.pm25] << 8) | data[config.data.pm25 + 1];
                const pm10 = (data[config.data.pm10] << 8) | data[config.data.pm10 + 1];

                updateChart(pm1, pm25, pm10);
                log.textContent += `‚úÖ PM1: ${pm1}, PM2.5: ${pm25}, PM10: ${pm10}\n`;
              } else {
                log.textContent += `‚ùå Bad checksum\n`;
              }

              buffer.splice(0, frameLen); // discard processed frame
            }

            if (buffer.length > 100) {
              buffer = buffer.slice(-50); // protect against runaway buffer
            }
          }
        }
      } catch (err) {
        log.textContent += `‚ùå Read error: ${err}\n`;
      } finally {
        reader.releaseLock();
      }
    }

    function updateChart(pm1, pm25, pm10) {
      const ts = new Date().toLocaleTimeString();
      const labels = chart.data.labels;

      labels.push(ts);
      chart.data.datasets[0].data.push(pm1);
      chart.data.datasets[1].data.push(pm25);
      chart.data.datasets[2].data.push(pm10);

      if (labels.length > 100) {
        labels.shift();
        chart.data.datasets.forEach(d => d.data.shift());
      }

      chart.update();
    }

    disconnectBtn.addEventListener('click', async () => {
      isReading = false;

      if (reader) {
        try {
          await reader.cancel();
          await reader.releaseLock();
        } catch {}

        reader = null;
      }

      if (port) {
        try {
          await port.close();
          log.textContent += "üîí Port closed.\n";
        } catch (err) {
          log.textContent += `‚ùå Port close error: ${err}\n`;
        }
      }

      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
    });
  </script>
</body>
</html>
