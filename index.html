<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Serial Sensor Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .chart-wrapper {
      position: relative;
      margin-bottom: 40px;
    }
    .chart-container {
      width: 100%;
      height: 100%;
    }
    #log {
      white-space: pre-wrap;
      background: #f0f0f0;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    button {
      padding: 10px 15px;
      font-size: 1em;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <button id="connect">🔌 Connect</button>
  <button id="clearLog">🧹 Clear Log</button>
  <div id="charts"></div>
  <pre id="log"></pre>

  <script>
    let port = null, reader = null, writer = null, reading = false;
    let charts = {}, config;
    const log = document.getElementById('log');
    const connectBtn = document.getElementById('connect');
    let timeStart = performance.now();
    const MAX_POINTS = 1000;

    async function loadConfig() {
      const res = await fetch("https://raw.githubusercontent.com/WeSpeakEnglish/polluSensWeb/refs/heads/main/SN-GCJA5.json");
      config = await res.json();
    }

    function initializeCharts() {
      const chartsContainer = document.getElementById('charts');
      chartsContainer.innerHTML = '';
      charts = {};
      for (const [chartGroup, group] of Object.entries(config.charts)) {
        const wrapper = document.createElement('div');
        wrapper.className = 'chart-wrapper';

        const canvas = document.createElement('canvas');
        canvas.className = 'chart-container';

        const [width, height] = group.size || [600, 300];
        wrapper.style.maxWidth = `${width}px`;
        wrapper.style.height = `${height}px`;
        wrapper.style.width = '100%';

        wrapper.appendChild(canvas);
        chartsContainer.appendChild(wrapper);

        charts[chartGroup] = new Chart(canvas, {
          type: 'line',
          data: {
            datasets: group.datasets.map(([label, field, color, tension]) => ({
              label,
              data: [],
              borderColor: color,
              tension: tension ?? 0.3,
              borderWidth: 1,
              fill: false,
              pointRadius: 0
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Time (s)' }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: chartGroup }
              }
            },
            plugins: {
              legend: { position: 'top' }
            }
          }
        });
      }
    }

    function updateCharts(parsedData) {
      const now = (performance.now() - timeStart) / 1000;
      for (const [chartGroup, chart] of Object.entries(charts)) {
        const datasets = config.charts[chartGroup].datasets;
        datasets.forEach(([label, field], i) => {
          const value = parsedData[field];
          if (value !== undefined) {
            chart.data.datasets[i].data.push({ x: now, y: value });
            if (chart.data.datasets[i].data.length > MAX_POINTS) {
              chart.data.datasets[i].data.shift();
            }
          }
        });
        chart.update('none');
      }
    }

    async function sendCommandIfNeeded() {
      const command = config.command;
      if (!command || command.toLowerCase() === "none") return;

      const bytes = command.split(/\s+/).map(hex => parseInt(hex, 16));
      const data = new Uint8Array(bytes);
      writer = port.writable.getWriter();
      await writer.write(data);
      writer.releaseLock();
      log.textContent += `➡️ Sent command: [${bytes.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ')}]\n`;
    }

    async function readLoop() {
      const { frame, checksum, data: dataFields } = config;
      const useStart = frame.startByte !== "none";
      const useEnd = frame.endByte !== "none";
      const frameLength = frame.length;
      const startByte = useStart ? frame.startByte : null;
      const endByte = useEnd ? frame.endByte : null;

      let buffer = [];
      reading = true;

      while (reading) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer.push(...value);

        while (buffer.length >= frameLength) {
          let data;
          if (useStart && useEnd) {
            const slice = buffer.slice(0, frameLength);
            if (slice[0] === startByte && slice[frameLength - 1] === endByte) {
              data = slice;
              buffer = buffer.slice(frameLength);
            } else {
              buffer.shift();
              continue;
            }
          } else {
            data = buffer.slice(0, frameLength);
            buffer = buffer.slice(frameLength);
          }

          const valid = eval(checksum.eval) === eval(checksum.compare);
          if (valid) {
            const parsed = {};
            for (const [name, expr] of Object.entries(dataFields)) {
              parsed[name] = eval(expr);
            }
            updateCharts(parsed);

            const hexPacket = data.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            let output = `📦 [${hexPacket}]\nChecksum: ✅`;
            const seenFields = new Set();
            for (const groupConf of Object.values(config.charts)) {
              for (const [label, field] of groupConf.datasets) {
                if (!seenFields.has(field) && parsed[field] !== undefined) {
                  output += `\n${label}: ${parsed[field]}`;
                  seenFields.add(field);
                }
              }
            }
            log.textContent += output + '\n';
          } else {
            log.textContent += `❌ Bad checksum\n`;
          }
        }
      }
    }

    connectBtn.addEventListener('click', async () => {
      if (port) {
        reading = false;
        if (reader) {
          try {
            await reader.cancel();
            await reader.releaseLock();
          } catch (e) {}
        }
        await port.close();
        port = null;
        reader = null;
        connectBtn.textContent = '🔌 Connect';
        log.textContent += '🔌 Port closed\n';
        return;
      }

      try {
        await loadConfig();
        initializeCharts();
        port = await navigator.serial.requestPort();
        await port.open(config.port);
        reader = port.readable.getReader();
        connectBtn.textContent = '❌ Disconnect';
        log.textContent += '✅ Port opened\n';

        await sendCommandIfNeeded();
        await readLoop();
      } catch (err) {
        log.textContent += `❌ ${err.message}\n`;
        connectBtn.textContent = '🔌 Connect';
      }
    });

    document.getElementById('clearLog').addEventListener('click', () => {
      log.textContent = '';
    });
  </script>
</body>
</html>
