<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>polluSensWeb Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <link rel="stylesheet" href="styles.css">
  <style>
    .webhook-card { margin-top:25px; padding:15px; border:1px solid #ccc; border-radius:8px; }
    .header-row { display:flex; gap:6px; margin-top:6px; }
    .header-row input { flex:1; }
    .btn-remove { background:#ffe5e5; color:#a00; border:none; padding:4px 8px; border-radius:6px; cursor:pointer; }
    .btn-secondary { padding:6px 10px; border-radius:6px; border:none; background:#ddd; cursor:pointer; }
    .btn-primary { padding:6px 10px; border-radius:6px; border:none; background:#4a7afe; color:white; cursor:pointer; }
    .mode-toggle { display:flex; gap:10px; margin:10px 0; }
    .mode-btn { flex:1; padding:8px; border:2px solid #ccc; background:white; cursor:pointer; border-radius:8px; font-weight:600; }
    .mode-btn.active { border-color:#4a7afe; background:#e4e9ff; color:#4a7afe; }
    .status { padding: 10px; margin: 10px 0; border-radius: 4px; font-family: monospace; font-size: 12px; }
    .status.success { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .status.info { background: #d1ecf1; color: #0c5460; }
  </style>
</head>
<body>
  <header>
    <h1>Connect your UART pollution sensor via COM port. Easy.</h1>
    <div>
      <select id="sensorSelector"></select>
      <button id="connect">üîå Connect</button>
      <br/>
      <label>Custom JSON Sensor Configuration: <input type="file" id="jsonUpload" accept=".json" class="secondary-button" /></label>
    </div>
  </header>

  <div id="chartControls">
    <h3>Create a Chart</h3>
    <div class="chartParams">
      <label>Chart name:<input type="text" id="chartName" value="Chart" /></label>
      <label>Width:<input type="number" id="chartWidth" value="600" /></label>
      <label>Height:<input type="number" id="chartHeight" value="300" /></label>
      <label>Chart datapoints:<input type="number" id="maxDatapoints" value="600" min="2" /></label>
    </div>
    <div id="datasetConfigs"><h4>Signals</h4><div id="signalRows"></div></div>
    <button id="createChart">üìà Create Chart</button>
  </div>

  <div id="charts"></div>

  <div style="margin-bottom: 8px;">
    <label><b>Log:</b></label>
    <label>Display last <input type="number" id="maxLogPackets" value="1000" min="10" style="width:80px;" /> lines</label>
    <label style="margin-left:20px;"><input type="checkbox" id="autoscrollLog" checked /> Autoscroll</label>
    <button id="clearLog" class="secondary-button">üßπ Clear Log</button>
    <button id="saveCSV" class="secondary-button">üíæ Save CSV</button>
  </div>

  <pre id="log"></pre>

  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <!-- WEBHOOK (Sensor.Community preset + Proxy + Interval) -->
  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->

  <div class="webhook-card">
    <h3>Webhook (optional)</h3>

    <label><input type="checkbox" id="enableWebhook"> Enable Webhook Sending</label>

    <div id="webhookConfig" style="display:none; margin-top:12px;">

      <div class="mode-toggle">
        <button class="mode-btn active" id="whModeDirect">Direct Mode</button>
        <button class="mode-btn" id="whModeProxy">Proxy Mode</button>
      </div>

      <label>Webhook URL:
        <input type="url" id="webhookUrl" value="https://webhook.site/71e05947-aa4e-4e95-b442-18ef017c9255">
      </label>

      <label id="proxyLabel" style="display:none;">Proxy URL:
        <input type="text" id="proxyUrl" value="https://pollutants.eu/proxy/proxy.php" />
        <small>Using your proxy server</small>
      </label>

      <label>Sensor ID:
        <input type="text" id="webhookSensorId" value="pollusensweb-123456">
      </label>

      <label>Sensor Name:
        <input type="text" id="webhookSensorName" value="PM Sensor">
      </label>

      <label>Method:
        <select id="webhookMethod"><option>POST</option><option>PUT</option></select>
      </label>

      <label>Send every (seconds):
        <input type="number" id="webhookInterval" value="0" min="0" />
        <small>(0 = send per packet)</small>
      </label>

      <h4>Headers</h4>
      <div id="headersContainer"></div>
      <button id="addHeader" class="btn-secondary">+ Add header</button>
      <button id="clearHeaders" class="btn-secondary">Clear all headers</button>

      <h4>Body Template</h4>
      <textarea id="webhookBody" rows="14" style="width:100%;">{
  "software_version": "polluSensWeb 1.0",
  "timestamp": "{{ts}}",
  "sensor": "{{sensor}}",
  "sensor_id": "{{id}}",
  "sensordatavalues": [
    {{#fields}}
      { "value_type": "{{key}}", "value": "{{value}}" }
    {{/fields}}
  ]
}</textarea>

      <label><input type="checkbox" id="webhookOnPacket" checked> Send webhook on every parsed packet</label>

      <div style="background:#f0f0f0; padding:10px; margin:10px 0; border-radius:4px; font-size:12px;">
        <strong>üìä Debug Info:</strong>
        <div>Packets received: <span id="packetCount">0</span></div>
        <div>Webhooks sent: <span id="webhookCount">0</span></div>
        <div>Last packet time: <span id="lastPacketTime">-</span></div>
      </div>

      <button id="testWebhook" class="btn-primary" style="margin-top:10px;">üß™ Test Send Webhook Now</button>
      <button id="testProxyGet" class="btn-secondary" style="margin-top:10px;">üîç Test Proxy (GET request)</button>
      <button id="simulatePacket" class="btn-secondary" style="margin-top:10px;">üì¶ Simulate Sensor Packet</button>

      <div id="statusLog"></div>
    </div>
  </div>

<script src="pollusensweb.js"></script>

<script>
window.updateCharts = window.updateCharts || function(){};
</script>

<script>
// Show/hide config
enableWebhook.onchange = () => {
  webhookConfig.style.display = enableWebhook.checked ? "block" : "none";
};

// Proxy mode toggle
let useProxy = false;
whModeDirect.onclick = () => { 
  useProxy = false; 
  whModeDirect.classList.add("active"); 
  whModeProxy.classList.remove("active");
  proxyLabel.style.display = "none";
  logStatus("Switched to Direct Mode", "info");
};

whModeProxy.onclick = () => { 
  useProxy = true; 
  whModeProxy.classList.add("active"); 
  whModeDirect.classList.remove("active");
  proxyLabel.style.display = "block";
  logStatus("Switched to Proxy Mode", "info");
};

// Dynamic header rows
function addHeaderRow(key = "", val = "") {
  const row = document.createElement("div"); 
  row.className = "header-row";
  row.innerHTML = `<input class="hKey" placeholder="Key" value="${key}">
                   <input class="hVal" placeholder="Value" value="${val}">
                   <button class="btn-remove">X</button>`;
  row.querySelector(".btn-remove").onclick = () => row.remove();
  headersContainer.appendChild(row);
}

// Default headers
addHeaderRow("X-PIN", "0");
addHeaderRow("X-Sensor", "{{id}}");
addHeaderRow("X-Device", "{{id}}");
addHeaderRow("Content-Type", "application/json");
addHeader.onclick = () => addHeaderRow();
clearHeaders.onclick = () => {
  headersContainer.innerHTML = "";
  addHeaderRow("Content-Type", "application/json");
  logStatus("Headers reset to default", "info");
};

// Status logger
let packetCounter = 0;
let webhookCounter = 0;

function logStatus(message, type = "info") {
  const log = document.createElement("div");
  log.className = `status ${type}`;
  const timestamp = new Date().toLocaleTimeString();
  log.textContent = `[${timestamp}] ${message}`;
  statusLog.insertBefore(log, statusLog.firstChild);
  
  // Keep only last 10 messages
  while (statusLog.children.length > 10) {
    statusLog.removeChild(statusLog.lastChild);
  }
}

// Template processors
function applyHeaders() {
  const id = webhookSensorId.value;
  const headers = {};
  document.querySelectorAll(".header-row").forEach(r => {
    const k = r.querySelector(".hKey").value.trim();
    const v = r.querySelector(".hVal").value.replace(/{{id}}/g, id).trim();
    if (k) headers[k] = v;
  });
  return headers;
}

function applyBody(template, parsed) {
  let out = template;
  out = out.replace(/{{ts}}/g, new Date().toISOString());
  out = out.replace(/{{sensor}}/g, webhookSensorName.value || "sensor");
  out = out.replace(/{{id}}/g, webhookSensorId.value);

  // {{field:NAME}}
  out = out.replace(/{{field:([^}]+)}}/g, (_, f) => {
    return parsed[f] !== undefined ? parsed[f] : "null";
  });

  // {{#fields}} ... {{/fields}}
  out = out.replace(/{{#fields}}([\s\S]*?){{\/fields}}/g, (_, block) => {
    const entries = Object.entries(parsed)
      .filter(([k,v]) => v !== null && v !== undefined && isFinite(v));
    
    if (entries.length === 0) return "";
    
    return entries
      .map(([key,val], idx) => {
        let line = block.replace(/{{key}}/g, key).replace(/{{value}}/g, val).trim();
        // Remove trailing comma from last item
        if (idx === entries.length - 1) {
          line = line.replace(/,\s*$/, "");
        }
        return line;
      })
      .join(",\n    ");
  });
  
  return out;
}

// Send webhook function
async function sendWebhook(parsed) {
  if (!enableWebhook.checked) {
    return;
  }

  try {
    webhookCounter++;
    if (webhookCount) webhookCount.textContent = webhookCounter;
    
    const baseUrl = webhookUrl.value;
    // Fixed: Build proxy URL correctly
    const url = useProxy ? `${proxyUrl.value}?url=${encodeURIComponent(baseUrl)}` : baseUrl;
    const method = webhookMethod.value;
    const headers = applyHeaders();
    const body = applyBody(webhookBody.value, parsed);

    logStatus(`Sending ${method} to ${useProxy ? 'proxy ‚Üí ' : ''}${baseUrl}`, "info");
    console.log("=== WEBHOOK REQUEST #" + webhookCounter + " ===");
    console.log("Full URL:", url);
    console.log("Method:", method);
    console.log("Headers:", headers);
    console.log("Body:", body);

    const fetchOptions = { 
      method, 
      headers, 
      body,
      mode: 'cors'
    };

    const response = await fetch(url, fetchOptions);

    console.log("Response status:", response.status);

    if (response.ok) {
      const responseText = await response.text();
      logStatus(`‚úÖ Success! Status: ${response.status}`, "success");
      console.log("Response body:", responseText);
    } else {
      logStatus(`‚ùå Failed: ${response.status} ${response.statusText}`, "error");
      const errorText = await response.text();
      console.error("Error response body:", errorText);
    }
  } catch (error) {
    logStatus(`‚ùå Error: ${error.message}`, "error");
    console.error("=== FETCH ERROR ===");
    console.error("Error message:", error.message);
    
    if (error.message.includes("Failed to fetch")) {
      logStatus("üí° This is likely a CORS preflight (OPTIONS) issue", "error");
      logStatus("üí° Check browser Network tab for the OPTIONS request", "info");
    }
  }
}

// Test button - creates fake sensor data
testWebhook.onclick = async () => {
  const testData = {
    PM25: 15.3, 
    PM10: 23.7, 
    temperature: 22.5, 
    humidity: 45
  };
  logStatus("Testing webhook with sample data...", "info");
  console.log("Test data:", testData);
  await sendWebhook(testData);
};

// Test proxy with GET request
testProxyGet.onclick = async () => {
  try {
    const baseUrl = webhookUrl.value;
    const proxyTestUrl = `${proxyUrl.value}?url=${encodeURIComponent(baseUrl)}`;
    
    logStatus(`Testing proxy GET: ${proxyTestUrl}`, "info");
    console.log("Proxy test URL:", proxyTestUrl);
    
    const response = await fetch(proxyTestUrl, {
      method: 'GET',
      mode: 'cors'
    });
    
    if (response.ok) {
      const text = await response.text();
      logStatus(`‚úÖ Proxy works! Status: ${response.status}`, "success");
      console.log("Proxy response:", text);
    } else {
      logStatus(`‚ùå Proxy returned: ${response.status} ${response.statusText}`, "error");
      const errorText = await response.text();
      console.error("Proxy error:", errorText);
    }
  } catch (error) {
    logStatus(`‚ùå Proxy test failed: ${error.message}`, "error");
    console.error("Proxy test error:", error);
  }
};

// Simulate a sensor packet to test the integration
simulatePacket.onclick = () => {
  const fakePacket = {
    PM25: Math.random() * 50,
    PM10: Math.random() * 100,
    temperature: 20 + Math.random() * 10,
    humidity: 40 + Math.random() * 20
  };
  
  console.log("üé≠ Simulating sensor packet:", fakePacket);
  logStatus("Simulating sensor packet...", "info");
  
  // Call updateCharts as if it came from the sensor
  if (typeof window.updateCharts === 'function') {
    window.updateCharts(fakePacket);
    logStatus("Packet sent to updateCharts()", "success");
  } else {
    logStatus("‚ùå window.updateCharts is not defined!", "error");
    console.error("window.updateCharts is not a function:", window.updateCharts);
  }
};

// Interval handling
let intervalTimer = null;
let lastParsed = null;

// Wait for pollusensweb.js to load, then wrap updateCharts
(function(){
  // Save the original updateCharts from pollusensweb.js
  const originalUpdateCharts = window.updateCharts;
  
  // Replace it with our wrapper
  window.updateCharts = function(parsed){
    // Update packet counter
    packetCounter++;
    if (packetCount) packetCount.textContent = packetCounter;
    if (lastPacketTime) lastPacketTime.textContent = new Date().toLocaleTimeString();
    
    // Call original function from pollusensweb.js
    if (typeof originalUpdateCharts === 'function') {
      originalUpdateCharts(parsed);
    }
    
    // Don't send if webhook is disabled
    if (!enableWebhook.checked) return;

    const interval = Number(webhookInterval.value);
    lastParsed = parsed;

    console.log("üì¶ Packet #" + packetCounter + " received:", parsed);

    if (interval > 0) {
      // Interval mode - send every X seconds
      if (!intervalTimer) {
        console.log(`‚è∞ Starting interval timer: ${interval} seconds`);
        logStatus(`Interval mode: sending every ${interval} seconds`, "info");
        intervalTimer = setInterval(() => {
          if (lastParsed) {
            console.log("‚è∞ Interval timer triggered, sending webhook");
            sendWebhook(lastParsed);
          }
        }, interval * 1000);
      }
    } else {
      // Per-packet mode - send immediately on each packet
      if (webhookOnPacket.checked) {
        console.log("üöÄ Per-packet mode: sending webhook immediately");
        sendWebhook(parsed);
      }
    }
  };
  
  console.log("‚úÖ Webhook wrapper installed. Original updateCharts type:", typeof originalUpdateCharts);
})();

// Clean up interval on disable
enableWebhook.addEventListener('change', () => {
  if (!enableWebhook.checked && intervalTimer) {
    clearInterval(intervalTimer);
    intervalTimer = null;
    logStatus("Webhook disabled, interval cleared", "info");
  }
});

// Initialize
logStatus("Webhook system ready", "info");
console.log("Initial window.updateCharts:", typeof window.updateCharts);
</script>

</body>
</html>